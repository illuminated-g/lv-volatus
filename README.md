# Volatus
*Latin for Flight*

## Introduction

Volatus is a full application framework, primarily for LabVIEW. Initially intended for use on a rocket engine test stand and propulsion components testing, Volatus is designed to scale all the way from large distributed test systems with several operators and data acquisition and control components down to single process simple DAQ applciations, utilities, and automation tools.

Volatus is highly opinionated about several implementation details to provide tightly integrated and optimized features useful in these kinds of applications. *See [Dependencies](#dependencies) below.* All networking features are configurable and optional. For networked applications, Google's [ProtoBuf](https://protobuf.dev) serialization format is used for the UDP and TCP communications to enable easier implementation of apps and tooling in other languages. A [Python package](https://pypi.org/project/ig-volatus/) has already been started to enable the creation of scripts and Python applications that can interact with systems built using Volatus.

### Configurability
Configurability is a primary design pillar for Volatus with the notion of minimizing the number of executable builds that need to be maintained. Different executables could be maintained for different targets (Windows, Linux, RT) and for managing different dependencies such as having a separate Windows executable that doesn't require the DAQmx run-time to be installed for GUI applications that communicate with distribute RT controllers. With this in mind, Volatus directly utilizes my *IG Config* library for all levels of configuration. While intended to load config files from disk (with implementations for JSON and SQLite while being extensible to other databases/formats) configuration can also be programmatically generated and several mechanisms are provided for initializing applications to allow different configuration sources.

### Modules
Volatus organizes functionality into *modules* which are communicated with via encapsulated Message queues (*MessageQ*). Modules are implemented with Queued Message Handler (QMH) patterns and several templates are provided for quicker development for common use-cases. Modules follow a nesting hierarchy identical to Actor Framework but does not utilize Object-Oriented Programming for internal messaging. *Networked messaging does use classes generated by my ProtoBuf tooling to encapsulate the serialization and data handling behaviors.*

### Debugging
Volatus provides many built-in debugging capabilities such as:
- Debug (event) logging both to file and displayable in GUIs
- HTTP server for accessing configuration, debug logs, and other information when networking and HTTP is configured
- Configuration monitoring and GUI components dedicated to notifying operators of configuration issues
- GUI elements that use coloring to signify internal state and provide awareness of configuration problems

### GUIs
Volatus provides a plugin GUI implementation to enable dynamically loading no-code VIs from disk during run-time. GUI VIs can be closed, updated, and reopened during run-time without stopping the application. No-code GUI VIs can put GUI element configuration directly into an element's *Description* property field. Implementations for element behaviors have access to the full framework's capabilities and can interact with modules, networked data, and nearly anything imaginable. Element behaviors can be simple indicators and controls for numerics and booleans. Element behaviors can also be as complex as necessary to represent multi-state valves with command and limit switch feedback, graph buffering management and display control, data logging control and state feedback, and just about anything else imaginable.

## Dependencies
These are the primary source dependencies for Volatus
- [IG Vecto](https://github.com/illuminated-g/lv-vecto) for network comms.
- [IG Config](https://github.com/illuminated-g/lv-cdm) for configuration.
- [IG HTTP Server](https://github.com/illuminated-g/lv-http-server) for http server and websockets.
- [IG Promises](https://github.com/illuminated-g/lv-promises) for async intra-app messaging reponses.
- [IG Proto](https://github.com/illuminated-g/lv-protoc) for LabVIEW ProtoBuf serialization code generation and run-time support.
- [JSONtext](https://www.vipm.io/package/jdp_science_jsontext/) for JSON generation and parsing
- [SQLite](https://www.vipm.io/package/drjdpowell_lib_sqlite_labview/) when using SQLite storage format for configuration

## Application Hierarchy
Volatus follows Vecto's organization for distributed applications and data. For more details check out the Vecto repository link in [Dependencies](#dependencies) above.
- System
  - All components for a single test stand.
- Cluster
  - All nodes that directly communicate with each other.
  - Most systems will only utilize a single cluster.
- Node
  - An application running as part of a cluster.
  - Examples are a DAQ node, Sequencing node, Console GUI node, etc.
- Task
  - A top-level module within an application that generally will own or work with Group data.
  - Can organize functionality into nested modules that can be launched nested underneath the task.
  - Tasks have entries within the configuration file whereas other modules are not required to.
- Group
  - A collection of channel data that is updated at the same rate.
  - Currently supports Doubles and Strings; String representations can be used a means for handling heterogeneous data types.
  - All channels in a group are the same type.
- Channel
  - A discrete element of data
